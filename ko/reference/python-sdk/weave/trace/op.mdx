---
- title: Op
- description: 함수 호출을 추적하기 위한 Op 데코레이터 및 관련 기능
---

The `@weave.op` 데코레이터는 Weave에서 함수 호출을 추적하는 데 사용됩니다. 데코레이트된 함수의 입력, 출력 및 메타데이터를 자동으로 기록합니다.

## 기본 사용법

```python
import weave

@weave.op
def my_function(x: int, y: int) -> int:
    return x + y

# When called, this function is automatically tracked
result = my_function(3, 4)
```

## 데코레이터 옵션

### name

작업의 사용자 지정 이름을 설정합니다.

```python
@weave.op(name="custom_operation_name")
def my_function():
    pass
```

### call\_display\_name

이 작업의 모든 호출에 대한 표시 이름을 설정합니다.

```python
@weave.op(call_display_name="My Custom Display")
def my_function():
    pass
```

함수를 사용하여 표시 이름을 동적으로 생성할 수도 있습니다:

```python
def generate_name(call):
    return f"Processing {call.inputs['item_id']}"

@weave.op(call_display_name=generate_name)
def process_item(item_id: str):
    pass
```

### postprocess\_inputs

로깅되기 전에 입력을 변환합니다.

```python
def redact_sensitive(inputs):
    if 'password' in inputs:
        inputs['password'] = '[REDACTED]'
    return inputs

@weave.op(postprocess_inputs=redact_sensitive)
def login(username: str, password: str):
    pass
```

### postprocess\_output

로깅되기 전에 출력을 변환합니다.

```python
def format_output(output):
    return weave.Markdown(f"**Result:** {output}")

@weave.op(postprocess_output=format_output)
def generate_report():
    return "Analysis complete"
```

## Op 메서드

### call

결과와 Call 객체를 모두 가져옵니다.

```python
@weave.op
def my_function(x: int) -> int:
    return x * 2

result, call = my_function.call(5)
print(f"Result: {result}")
print(f"Call ID: {call.id}")
```

### name

작업 이름을 가져오거나 설정합니다.

```python
@weave.op
def my_function():
    pass

# Get the current name
print(my_function.name)

# Set a new name
my_function.name = "new_operation_name"
```

## 비동기 함수 작업

Weave는 비동기 작업을 지원합니다:

```python
@weave.op
async def async_operation(prompt: str) -> str:
    # Async operations are tracked the same way
    result = await some_async_api(prompt)
    return result
```

## 제너레이터 작업

Weave는 제너레이터 함수를 추적할 수 있습니다:

```python
@weave.op
def generate_items(count: int):
    for i in range(count):
        yield f"Item {i}"

# The output is captured when the generator is consumed
items = list(generate_items(5))
```

## 클래스 메서드

클래스의 메서드를 데코레이트합니다:

```python
class MyClass:
    @weave.op
    def process(self, data: str) -> str:
        return data.upper()

instance = MyClass()
result = instance.process("hello")
```

## 정적 및 클래스 메서드

```python
class MyClass:
    @staticmethod
    @weave.op
    def static_method(x: int) -> int:
        return x * 2
    
    @classmethod
    @weave.op
    def class_method(cls, x: int) -> int:
        return x * 3
```

<Note>
  The `@weave.op` 데코레이터는 데코레이터를 중첩할 때 가장 안쪽 데코레이터여야 합니다.
</Note>
