---
- title: トラブルシューティング
- description: Weaveで遭遇する可能性のある一般的な問題に対する解決策とガイダンス
---

このページでは、遭遇する可能性のある一般的な問題に対するソリューションとガイダンスを提供しています。このガイドを拡張し続けるにつれて、より広範なシナリオに対応するためのトラブルシューティングトピックが追加されます。

<Tip>
  コミュニティと共有したいWeaveのトラブルシューティングアドバイスがありますか？このガイドの下部にある**Edit this page**をクリックして、プルリクエストを送信することで直接貢献できます。
</Tip>

## トレースページの読み込みが遅い

トレースページの読み込みが遅い場合は、表示される行数を減らして読み込み時間を改善してください。デフォルト値は`50`です。UIを通じて、またはクエリパラメータを使用して行数を減らすことができます。

### UIで調整する（推奨）

トレースページの右下にある**Per page**コントロールを使用して、表示される行数を調整します。デフォルトの`50`に加えて、`10`、`25`、または`100`に設定することもできます。

### クエリパラメータを使用する

手動アプローチを好む場合は、クエリURLの`pageSize`クエリパラメータを最大値の`100`未満の値に変更できます。

## サーバーレスポンスのキャッシング

Weaveは、繰り返しクエリを行う場合や、ネットワーク帯域幅が限られている場合のパフォーマンスを向上させるために、サーバーレスポンスのキャッシングを提供しています。現在はデフォルトで無効になっていますが、この機能は将来のリリースでデフォルトの動作になる予定です。

### キャッシングを使用するタイミング

サーバーレスポンスのキャッシングは、特に次の場合に有益です：

* 同じクエリを頻繁に実行する
* ネットワーク帯域幅が制限されている
* レイテンシが高い環境で作業している
* オフラインで開発していて、後で使用するためにレスポンスをキャッシュしたい

この機能は、データセットに対して繰り返し評価を実行する場合に特に役立ちます。実行間でデータセットをキャッシュできるためです。

### キャッシングを有効にする方法

キャッシングを有効にするには、以下の環境変数を設定できます：

```bash
# Enable server response caching
export WEAVE_USE_SERVER_CACHE=true

# Set cache size limit (default is 1GB)
export WEAVE_SERVER_CACHE_SIZE_LIMIT=1000000000

# Set cache directory (optional, defaults to temporary directory)
export WEAVE_SERVER_CACHE_DIR=/path/to/cache
```

### キャッシングの動作

技術的には、この機能はサーバーに対する冪等なリクエストをキャッシュします。具体的には、以下をキャッシュします：

* `obj_read`
* `table_query`
* `table_query_stats`
* `refs_read_batch`
* `file_content_read`

### キャッシュサイズとストレージの詳細

キャッシュサイズは次によって制御されます `WEAVE_SERVER_CACHE_SIZE_LIMIT` (バイト単位)。実際のディスク使用量は3つのコンポーネントで構成されています：

1. 一定の32KBチェックサムファイル
2. 実行中のクライアントごとに最大約4MBのWrite-Ahead Log (WAL)ファイル（プログラム終了時に自動的に削除されます）
3. メインデータベースファイル（最小32KB、最大 `WEAVE_SERVER_CACHE_SIZE_LIMIT`

使用される総ディスク容量：

* 実行中 >= 32KB + \~4MB + キャッシュサイズ
* 終了後 >= 32KB + キャッシュサイズ

例えば、5MBのキャッシュ制限の場合：

* 実行中：最大約9MB
* 終了後：最大約5MB

## トレースデータが切り詰められる

大きなトレースデータがWeave UIで部分的に切り取られることがあります。この問題は、デフォルトのトレース出力がWeaveがシリアル化方法を知らない生の、カスタムPythonオブジェクトであるために発生します。

大きなトレースデータが切り取られないようにするには、すべてのトレースデータを返す文字列の辞書を定義してください。

```python
import weave

class MyObj:
    def __init__(self, x: int):
        self.x = x

    def __repr__(self):
        return f"MyObj(x={self.x})"

    def to_dict(self):
        return {"x": self.x}

@weave.op()
def make_my_obj():
    x = "s" * 10_000
    return MyObj(x)
```

## 評価のクリーンアップ時間が長い

大規模なデータセットで評価を実行する際のパフォーマンスを向上させるために、以下の2つの方法を一緒に使用する必要があります。

### フラッシング

大規模なデータセットで評価を実行する場合、データセットがバックグラウンドスレッドでアップロードされている間、プログラム実行前に長い時間がかかることがあります。これは一般的に、メインスレッドの実行がバックグラウンドのクリーンアップが完了する前に終了した場合に発生します。`client.flush()` を呼び出すと、すべてのバックグラウンドタスクがメインスレッドで処理され、メインスレッド実行中の並列処理が確保されます。これにより、ユーザーコードがデータがサーバーにアップロードされる前に完了した場合のパフォーマンスが向上します。

Example:

```python
client = weave.init("fast-upload")

# ... evaluation setup
result = evaluation.Evaluate(dataset_id="my_dataset_id")

client.flush()
```

### クライアントの並列処理の増加

クライアントの並列処理は環境に基づいて自動的に決定されますが、以下の環境変数を使用して手動で設定できます：

* `WEAVE_CLIENT_PARALLELISM`：並列処理に利用可能なスレッド数。この数を増やすと、並列処理に利用可能なスレッド数が増加し、データセットのアップロードなどのバックグラウンドタスクのパフォーマンスが向上する可能性があります。

これはプログラムで `settings` 引数を `weave.init()` に設定することもできます：

```python
client = weave.init("fast-upload", settings={"client_parallelism": 100})
```

## OSエラー

### `[Errno 24]: Too many open files`

このエラーは、開いているファイルの数がオペレーティングシステムによって設定された制限を超えた場合に発生します。Weaveでは、大規模な画像データセットを扱っている場合にこれが発生する可能性があります。Weaveは画像処理に `PIL` を使用しており、これはプログラムの実行中、ファイル記述子を開いたままにします。

この問題を解決するには、開いているファイルのシステム制限を `65,536` に増やします `ulimit` を使用して：

```bash
ulimit -n 65536
```
